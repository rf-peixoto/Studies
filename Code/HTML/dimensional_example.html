<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dimensions Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #07090c;
      --card-bg: #10131a;
      --accent: #4ea1ff;
      --accent-soft: rgba(78, 161, 255, 0.15);
      --text-main: #e5e9f0;
      --text-muted: #8b92a4;
      --border-subtle: #1b232f;
      --radius-lg: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111522 0, #050609 45%, #020309 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 2rem 1rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1, h2, h3 {
      font-weight: 500;
      letter-spacing: 0.04em;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.9rem;
      max-width: 650px;
      text-align: center;
      margin-bottom: 2rem;
    }

    .badge {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent);
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(78,161,255,0.4);
      background: radial-gradient(circle at top, rgba(78,161,255,0.12), transparent 70%);
      margin-bottom: 0.75rem;
      display: inline-block;
    }

    .container {
      max-width: 1000px;
      width: 100%;
      display: grid;
      gap: 1.5rem;
    }

    @media (min-width: 900px) {
      .container {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .card {
      background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.6));
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 1.25rem 1.25rem 1rem;
      box-shadow: 0 18px 40px rgba(0,0,0,0.5);
      position: relative;
      overflow: hidden;
      outline: none;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at top left, rgba(78,161,255,0.07), transparent 55%),
        radial-gradient(circle at bottom right, rgba(166,77,255,0.06), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
    }

    .card:focus-visible {
      box-shadow: 0 0 0 1px rgba(78,161,255,0.8), 0 18px 40px rgba(0,0,0,0.7);
      border-color: rgba(78,161,255,0.9);
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.75rem;
      gap: 0.75rem;
    }

    .card-title {
      font-size: 1rem;
      text-transform: uppercase;
    }

    .card-caption {
      color: var(--text-muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .card-body {
      margin-top: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .hint {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.25);
      font-size: 0.7rem;
      white-space: nowrap;
    }

    .pill-dot {
      width: 0.4rem;
      height: 0.4rem;
      border-radius: 999px;
      background: var(--accent);
    }

    .controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .controls-row-right {
      margin-left: auto;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .coord-display {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* 1D LINE --------------------------------------------------------- */

    .line-viewport {
      margin-top: 0.25rem;
      padding: 1rem 0.2rem 0.3rem;
    }

    .line-track {
      position: relative;
      height: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(78,161,255,0.08), rgba(78,161,255,0.6));
      overflow: visible;
    }

    .line-marker {
      position: absolute;
      top: 50%;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(78,161,255,0.9);
    }

    .line-value {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .line-slider {
      width: 100%;
    }

    /* 2D MATRIX ------------------------------------------------------- */

    .matrix-viewport {
      margin-top: 0.25rem;
      padding: 0.9rem 0.2rem 0.4rem;
    }

    .matrix-grid {
      --n: 5;
      display: grid;
      grid-template-columns: repeat(var(--n), 1.6rem);
      grid-auto-rows: 1.6rem;
      gap: 0.25rem;
      justify-content: center;
      margin-bottom: 0.5rem;
    }

    .matrix-cell {
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background: radial-gradient(circle at top, rgba(255,255,255,0.06), rgba(0,0,0,0.6));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .matrix-cell.active {
      border-color: var(--accent);
      background: radial-gradient(circle at top, rgba(78,161,255,0.3), rgba(0,0,0,0.85));
      color: #f8fbff;
      box-shadow: 0 0 18px rgba(78,161,255,0.6);
    }

    .matrix-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(3,6,12,0.85);
      color: var(--text-main);
      padding: 0.25rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      transition: border-color 0.12s ease, background 0.12s ease, transform 0.1s ease;
    }

    .btn.small {
      padding: 0.15rem 0.55rem;
      font-size: 0.75rem;
    }

    .btn:hover {
      border-color: var(--accent);
      background: rgba(78,161,255,0.18);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-ghost {
      background: transparent;
    }

    /* 3D & 4D VIEWPORTS ---------------------------------------------- */

    .viewport-3d {
      margin-top: 0.5rem;
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      background: radial-gradient(circle at top, rgba(255,255,255,0.06), rgba(0,0,0,0.95));
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .viewport-3d.drag-active {
      box-shadow: 0 0 0 1px rgba(78,161,255,0.9), 0 18px 40px rgba(0,0,0,0.9);
      border-color: rgba(78,161,255,0.9);
    }

    .viewport-3d-inner {
      width: 8rem;
      height: 8rem;
      position: relative;
      perspective: 900px;
      cursor: grab;
    }

    .viewport-3d-inner.dragging {
      cursor: grabbing;
    }

    .rotator-3d {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      transform-origin: center;
      transition: transform 0.03s linear;
    }

    .cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
    }

    .face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: radial-gradient(circle at top left, rgba(78,161,255,0.12), rgba(0,0,0,0.9));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: var(--text-main);
      box-shadow: 0 0 24px rgba(0,0,0,0.7);
      backdrop-filter: blur(3px);
    }

    .face.front  { transform: translateZ(4rem); }
    .face.back   { transform: rotateY(180deg) translateZ(4rem); }
    .face.right  { transform: rotateY(90deg) translateZ(4rem); }
    .face.left   { transform: rotateY(-90deg) translateZ(4rem); }
    .face.top    { transform: rotateX(90deg) translateZ(4rem); }
    .face.bottom { transform: rotateX(-90deg) translateZ(4rem); }

    .face-label {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      opacity: 0.92;
    }

    .axis-label {
      position: absolute;
      font-size: 0.65rem;
      color: var(--text-muted);
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      pointer-events: none;
      opacity: 0.85;
    }

    .axis-label.x { bottom: 0.45rem; right: 1.2rem; }
    .axis-label.y { top: 0.45rem; left: 1.2rem; }
    .axis-label.z { top: 0.45rem; right: 1.1rem; }

    .value-pill {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      color: var(--accent);
      background: var(--accent-soft);
      border-radius: 999px;
      padding: 0.1rem 0.6rem;
      border: 1px solid rgba(78,161,255,0.7);
      white-space: nowrap;
    }

    /* Sliders */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 0 9px rgba(78,161,255,0.9);
      border: none;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 0 9px rgba(78,161,255,0.9);
      border: none;
    }

    input[type="range"]::-moz-range-track {
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
    }

    /* 4D specific small HUD */
    .hud {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .hud strong {
      color: var(--accent);
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="badge">Dimensional Playground</div>
  <h1>Interactive Dimensions</h1>
  <p class="subtitle">
    A minimalistic static page showing 1D, 2D, 3D and a 4D-style tesseract projection.
    Drag, click, and slide to move through dimensions.
  </p>

  <main class="container">
    <!-- 1D -------------------------------------------------------------->
    <section class="card" tabindex="0">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">1D · Line</h2>
            <div class="card-caption">Single coordinate <code>x</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            scalar position
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            Move the marker along the line. A point in 1D is described by a single number <code>x</code>.
          </p>

          <div class="line-viewport">
            <div class="line-track" id="lineTrack">
              <div class="line-marker" id="lineMarker"></div>
            </div>
            <div class="line-value">
              <span>Position:</span>
              <span class="value-pill" id="lineValue">x = 0.00</span>
            </div>
          </div>

          <input
            class="line-slider"
            id="lineSlider"
            type="range"
            min="0"
            max="100"
            step="0.1"
            value="0"
          />
        </div>
      </div>
    </section>

    <!-- 2D -------------------------------------------------------------->
    <section class="card" tabindex="0">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">2D · Grid</h2>
            <div class="card-caption">Coordinates <code>(x, y)</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            matrix navigation
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            Navigate the active cell using the buttons or your keyboard arrows. A point in 2D uses two numbers.
          </p>

          <div class="matrix-viewport">
            <div class="matrix-grid" id="matrixGrid">
              <!-- cells are generated by JS -->
            </div>

            <div class="matrix-controls">
              <div class="controls-row">
                <div class="controls-row">
                  <button class="btn small" data-dir="up">↑</button>
                </div>
                <div class="controls-row">
                  <button class="btn small" data-dir="left">←</button>
                  <button class="btn small" data-dir="down">↓</button>
                  <button class="btn small" data-dir="right">→</button>
                </div>
              </div>
              <div class="coord-display" id="matrixCoord">
                (x, y) = (0, 0)
              </div>
            </div>
          </div>

          <p class="hint">
            Tip: focus this card and use your arrow keys to move.
          </p>
        </div>
      </div>
    </section>

    <!-- 3D -------------------------------------------------------------->
    <section class="card" tabindex="0">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">3D · Cube</h2>
            <div class="card-caption">Coordinates <code>(x, y, z)</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            drag · arrows · reset
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            Click / touch and drag inside the viewport to rotate the cube in 3D.
            When this card is focused, arrow keys also rotate it; press <code>R</code> to reset.
          </p>

          <div class="viewport-3d" id="cubeViewport">
            <div class="viewport-3d-inner" id="cubeViewportInner">
              <div class="rotator-3d" id="cubeRotator">
                <div class="cube">
                  <div class="face front"><span class="face-label">+Z</span></div>
                  <div class="face back"><span class="face-label">−Z</span></div>
                  <div class="face right"><span class="face-label">+X</span></div>
                  <div class="face left"><span class="face-label">−X</span></div>
                  <div class="face top"><span class="face-label">+Y</span></div>
                  <div class="face bottom"><span class="face-label">−Y</span></div>
                </div>
              </div>
            </div>

            <span class="axis-label x">x</span>
            <span class="axis-label y">y</span>
            <span class="axis-label z">z</span>
          </div>

          <div class="controls-row">
            <span class="hint">3D rotation is just adding one more coordinate <code>z</code>.</span>
            <button class="btn small btn-ghost" id="cubeReset">Reset view</button>
          </div>
        </div>
      </div>
    </section>

    <!-- 4D -------------------------------------------------------------->
    <section class="card" tabindex="0">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">4D · Tesseract Projection</h2>
            <div class="card-caption">Coordinates <code>(x, y, z, w)</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            4D → 3D → 2D
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            This is a real 4D hypercube (tesseract) projection. Vertices live in <code>(x, y, z, w)</code>.
            The slider rotates in planes that involve <code>w</code>. Drag / touch to rotate the 3D view.
            When focused, use arrow keys to rotate the view, and <code>Q</code>/<code>E</code> to adjust 4D rotation;
            press <code>R</code> to reset.
          </p>

          <div class="viewport-3d" id="tessViewport">
            <canvas id="tessCanvas"></canvas>
            <span class="axis-label x">x</span>
            <span class="axis-label y">y</span>
            <span class="axis-label z">z</span>
          </div>

          <div class="controls-row">
            <div class="hud" id="tessCoord">
              Hover a vertex to inspect its rotated 4D coordinates.
            </div>
          </div>

          <div class="controls-row">
            <label class="hint" for="wSlider">
              4D rotation involving <code>w</code>:
            </label>
            <div class="controls-row-right">
              <input
                id="wSlider"
                class="w-control"
                type="range"
                min="0"
                max="100"
                step="1"
                value="50"
              />
              <span class="value-pill" id="wValue">θ<sub>xw</sub> ≈ 0.55, θ<sub>yw</sub> ≈ 0.31</span>
              <button class="btn small btn-ghost" id="wReset">Reset</button>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ---------------- 1D LINE ----------------------------------------
    (function init1D() {
      const slider = document.getElementById("lineSlider");
      const marker = document.getElementById("lineMarker");
      const valueLabel = document.getElementById("lineValue");

      function updateFromSlider() {
        const v = parseFloat(slider.value); // 0..100
        const frac = v / 100;
        marker.style.left = (frac * 100) + "%";
        valueLabel.textContent = "x = " + frac.toFixed(2);
      }

      slider.addEventListener("input", updateFromSlider);
      updateFromSlider();
    })();

    // ---------------- 2D MATRIX --------------------------------------
    (function init2D() {
      const grid = document.getElementById("matrixGrid");
      const coordLabel = document.getElementById("matrixCoord");
      const size = 5; // 5x5 grid

      grid.style.setProperty("--n", size);

      let x = 0;
      let y = 0;

      const cells = [];
      for (let row = 0; row < size; row++) {
        cells[row] = [];
        for (let col = 0; col < size; col++) {
          const cell = document.createElement("div");
          cell.className = "matrix-cell";
          cell.dataset.row = row;
          cell.dataset.col = col;
          grid.appendChild(cell);
          cells[row][col] = cell;
        }
      }

      function updateActive() {
        cells.forEach(row => row.forEach(c => c.classList.remove("active")));
        cells[y][x].classList.add("active");
        coordLabel.textContent = `(x, y) = (${x}, ${y})`;
      }

      function move(dx, dy) {
        x = Math.max(0, Math.min(size - 1, x + dx));
        y = Math.max(0, Math.min(size - 1, y + dy));
        updateActive();
      }

      const btns = grid.parentElement.querySelectorAll("button[data-dir]");
      btns.forEach(btn => {
        btn.addEventListener("click", () => {
          const dir = btn.dataset.dir;
          if (dir === "up") move(0, -1);
          if (dir === "down") move(0, 1);
          if (dir === "left") move(-1, 0);
          if (dir === "right") move(1, 0);
        });
      });

      const card = grid.closest(".card");
      card.addEventListener("keydown", e => {
        switch (e.key) {
          case "ArrowUp":
            move(0, -1);
            e.preventDefault();
            break;
          case "ArrowDown":
            move(0, 1);
            e.preventDefault();
            break;
          case "ArrowLeft":
            move(-1, 0);
            e.preventDefault();
            break;
          case "ArrowRight":
            move(1, 0);
            e.preventDefault();
            break;
        }
      });

      updateActive();
    })();

    // Utility: drag-rotate for CSS 3D (3D cube)
    function attachDragRotationCSS(viewport, viewportInner, rotator, state) {
      let { rotX, rotY } = state;
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      function applyTransform() {
        rotator.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
      }

      // Mouse
      viewportInner.addEventListener("mousedown", (e) => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        viewportInner.classList.add("dragging");
        viewport.classList.add("drag-active");
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        rotY += dx * 0.5;
        rotX -= dy * 0.5;
        rotX = Math.max(-89, Math.min(89, rotX));
        state.rotX = rotX;
        state.rotY = rotY;
        applyTransform();
      });

      window.addEventListener("mouseup", () => {
        if (!dragging) return;
        dragging = false;
        viewportInner.classList.remove("dragging");
        viewport.classList.remove("drag-active");
      });

      // Touch
      viewportInner.addEventListener("touchstart", (e) => {
        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        dragging = true;
        lastX = t.clientX;
        lastY = t.clientY;
        viewportInner.classList.add("dragging");
        viewport.classList.add("drag-active");
      }, { passive: true });

      window.addEventListener("touchmove", (e) => {
        if (!dragging || e.touches.length !== 1) return;
        const t = e.touches[0];
        const dx = t.clientX - lastX;
        const dy = t.clientY - lastY;
        lastX = t.clientX;
        lastY = t.clientY;
        rotY += dx * 0.5;
        rotX -= dy * 0.5;
        rotX = Math.max(-89, Math.min(89, rotX));
        state.rotX = rotX;
        state.rotY = rotY;
        applyTransform();
      }, { passive: true });

      window.addEventListener("touchend", () => {
        if (!dragging) return;
        dragging = false;
        viewportInner.classList.remove("dragging");
        viewport.classList.remove("drag-active");
      });

      applyTransform();
    }

    // ---------------- 3D CUBE ----------------------------------------
    (function init3D() {
      const viewport = document.getElementById("cubeViewport");
      const inner = document.getElementById("cubeViewportInner");
      const rotator = document.getElementById("cubeRotator");
      const resetBtn = document.getElementById("cubeReset");
      const card = viewport.closest(".card");

      const state = { rotX: -24, rotY: 32 };
      attachDragRotationCSS(viewport, inner, rotator, state);

      function applyTransform() {
        rotator.style.transform = `rotateX(${state.rotX}deg) rotateY(${state.rotY}deg)`;
      }

      resetBtn.addEventListener("click", () => {
        state.rotX = -24;
        state.rotY = 32;
        applyTransform();
      });

      card.addEventListener("keydown", (e) => {
        let handled = false;
        const step = 5;
        switch (e.key) {
          case "ArrowUp":
            state.rotX = Math.max(-89, state.rotX - step);
            handled = true;
            break;
          case "ArrowDown":
            state.rotX = Math.min(89, state.rotX + step);
            handled = true;
            break;
          case "ArrowLeft":
            state.rotY -= step;
            handled = true;
            break;
          case "ArrowRight":
            state.rotY += step;
            handled = true;
            break;
          case "r":
          case "R":
            state.rotX = -24;
            state.rotY = 32;
            handled = true;
            break;
        }
        if (handled) {
          applyTransform();
          e.preventDefault();
        }
      });

      applyTransform();
    })();

// ---------------- 4D TESSERACT (REAL PROJECTION) --------------------
(function init4D() {
  const viewport = document.getElementById("tessViewport");
  const canvas = document.getElementById("tessCanvas");
  const slider = document.getElementById("wSlider");
  const valueLabel = document.getElementById("wValue");
  const resetBtn = document.getElementById("wReset");
  const coordHud = document.getElementById("tessCoord");
  const card = viewport.closest(".card");

  // IMPORTANT: create ctx BEFORE anything can call draw()
  const ctx = canvas.getContext("2d");

  // 16 vertices of the 4D hypercube: (±1, ±1, ±1, ±1)
  const vertices4D = [];
  for (let x of [-1, 1]) {
    for (let y of [-1, 1]) {
      for (let z of [-1, 1]) {
        for (let w of [-1, 1]) {
          vertices4D.push([x, y, z, w]);
        }
      }
    }
  }

  // Build edge list with flag indicating if it's a w-edge
  const edges = [];
  for (let i = 0; i < vertices4D.length; i++) {
    for (let j = i + 1; j < vertices4D.length; j++) {
      let diffCount = 0;
      let diffIndex = -1;
      for (let k = 0; k < 4; k++) {
        if (vertices4D[i][k] !== vertices4D[j][k]) {
          diffCount++;
          diffIndex = k;
        }
      }
      if (diffCount === 1) {
        edges.push({
          i,
          j,
          wEdge: diffIndex === 3
        });
      }
    }
  }

  // 4D rotation angles (XW and YW)
  let angleXW = Math.PI / 4;
  let angleYW = Math.PI / 6;

  // 3D view angles (camera yaw/pitch)
  let viewRotX = -0.6;
  let viewRotY = 0.8;

  // Interaction state
  let dragging = false;
  let lastX = 0;
  let lastY = 0;
  let userInteracted = false;
  let highlightIndex = null;

  function rotate4D_XW(p, angle) {
    const [x, y, z, w] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const x2 = x * c + w * s;
    const w2 = -x * s + w * c;
    return [x2, y, z, w2];
  }

  function rotate4D_YW(p, angle) {
    const [x, y, z, w] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const y2 = y * c + w * s;
    const w2 = -y * s + w * c;
    return [x, y2, z, w2];
  }

  function rotate3D_X(p, angle) {
    const [x, y, z] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const y2 = y * c - z * s;
    const z2 = y * s + z * c;
    return [x, y2, z2];
  }

  function rotate3D_Y(p, angle) {
    const [x, y, z] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const x2 = x * c + z * s;
    const z2 = -x * s + z * c;
    return [x2, y, z2];
  }

  function projectTo2D(p3) {
    const [x, y, z] = p3;
    const { width, height } = canvas;
    const scale = Math.min(width, height) * 0.22;
    const cx = width / 2;
    const cy = height / 2;
    const depth = 5;
    const factor = depth / (depth + z);
    const sx = x * scale * factor + cx;
    const sy = y * scale * factor + cy;
    return [sx, sy];
  }

  // Main draw function (uses ctx, now safely initialized)
  function draw() {
    const { width, height } = canvas;
    ctx.clearRect(0, 0, width, height);

    const projected = [];
    const rotated4List = [];
    const rotated3List = [];

    for (let idx = 0; idx < vertices4D.length; idx++) {
      let p4 = vertices4D[idx].slice();
      // 4D rotations
      p4 = rotate4D_XW(p4, angleXW);
      p4 = rotate4D_YW(p4, angleYW);
      rotated4List[idx] = p4;

      const [xr, yr, zr, wr] = p4;

      // 4D perspective using w
      const k4 = 3;
      const factor4 = k4 / (k4 - wr);
      let p3 = [xr * factor4, yr * factor4, zr * factor4];

      // 3D view rotations
      p3 = rotate3D_X(p3, viewRotX);
      p3 = rotate3D_Y(p3, viewRotY);
      rotated3List[idx] = p3;

      projected[idx] = projectTo2D(p3);
    }

    // Draw edges
    for (const edge of edges) {
      const i = edge.i;
      const j = edge.j;
      const [x1, y1] = projected[i];
      const [x2, y2] = projected[j];

      const z1 = rotated3List[i][2];
      const z2 = rotated3List[j][2];
      const avgZ = (z1 + z2) / 2;
      const normalizedDepth = 0.5 + Math.tanh(avgZ * 0.4) * 0.5;

      const baseAlpha = edge.wEdge ? 0.9 : 0.45;
      const alpha = baseAlpha * (0.4 + 0.6 * (1 - normalizedDepth));

      const color = edge.wEdge
        ? `rgba(255,210,120,${alpha})`
        : `rgba(78,161,255,${alpha})`;

      ctx.strokeStyle = color;
      ctx.lineWidth = edge.wEdge ? 1.4 : 1.1;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // Draw vertices
    for (let idx = 0; idx < projected.length; idx++) {
      const [x, y] = projected[idx];
      const [xr, yr, zr, wr] = rotated4List[idx];
      const baseRadius = 2.4;
      const inner = vertices4D[idx][3] > 0;

      let r = inner ? baseRadius + 0.9 : baseRadius;
      let fill;

      if (highlightIndex === idx) {
        r += 1.4;
        fill = "rgba(255,255,255,1)";
      } else {
        fill = inner
          ? "rgba(78,161,255,1)"
          : "rgba(190,205,255,0.75)";
      }

      const depthFade = 0.7 + 0.3 * (1 - Math.tanh(Math.abs(zr) * 0.4));

      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.globalAlpha = depthFade;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Resize handler (safe: ctx is already defined)
  function resizeCanvas() {
    const rect = viewport.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    draw();
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas(); // initial size + draw

  // Slider -> 4D angles
  function updateWAngle() {
    const v = parseInt(slider.value, 10); // 0..100
    const a = (v / 100) * Math.PI;       // 0..π
    angleXW = a * 0.7;
    angleYW = a * 0.4;
    valueLabel.innerHTML =
      `θ<sub>xw</sub> ≈ ${angleXW.toFixed(2)}, ` +
      `θ<sub>yw</sub> ≈ ${angleYW.toFixed(2)}`;
    draw();
  }

  slider.addEventListener("input", () => {
    userInteracted = true;
    updateWAngle();
  });

  resetBtn.addEventListener("click", () => {
    viewRotX = -0.6;
    viewRotY = 0.8;
    slider.value = "50";
    updateWAngle();
    coordHud.textContent =
      "Hover a vertex to inspect its rotated 4D coordinates.";
    userInteracted = true;
  });

  updateWAngle(); // initialize label & draw

  // Drag to rotate view
  function startDrag(clientX, clientY) {
    dragging = true;
    lastX = clientX;
    lastY = clientY;
    viewport.classList.add("drag-active");
  }

  function moveDrag(clientX, clientY) {
    if (!dragging) return;
    const dx = clientX - lastX;
    const dy = clientY - lastY;
    lastX = clientX;
    lastY = clientY;
    viewRotY += dx * 0.005;
    viewRotX += dy * 0.005;
    userInteracted = true;
    draw();
  }

  function endDrag() {
    if (!dragging) return;
    dragging = false;
    viewport.classList.remove("drag-active");
  }

  viewport.addEventListener("mousedown", (e) => {
    startDrag(e.clientX, e.clientY);
  });

  window.addEventListener("mousemove", (e) => {
    moveDrag(e.clientX, e.clientY);
  });

  window.addEventListener("mouseup", endDrag);
  viewport.addEventListener("mouseleave", endDrag);

  viewport.addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;
    const t = e.touches[0];
    startDrag(t.clientX, t.clientY);
  }, { passive: true });

  window.addEventListener("touchmove", (e) => {
    if (!dragging || e.touches.length !== 1) return;
    const t = e.touches[0];
    moveDrag(t.clientX, t.clientY);
  }, { passive: true });

  window.addEventListener("touchend", endDrag);

  // Hover: find nearest vertex and show its rotated 4D coordinates
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const projected = [];
    const rotated4List = [];

    for (let idx = 0; idx < vertices4D.length; idx++) {
      let p4 = vertices4D[idx].slice();
      p4 = rotate4D_XW(p4, angleXW);
      p4 = rotate4D_YW(p4, angleYW);
      rotated4List[idx] = p4;

      const [xr, yr, zr, wr] = p4;
      const k4 = 3;
      const factor4 = k4 / (k4 - wr);
      let p3 = [xr * factor4, yr * factor4, zr * factor4];
      p3 = rotate3D_X(p3, viewRotX);
      p3 = rotate3D_Y(p3, viewRotY);
      projected[idx] = projectTo2D(p3);
    }

    let minDist2 = Infinity;
    let bestIdx = null;
    for (let idx = 0; idx < projected.length; idx++) {
      const [x, y] = projected[idx];
      const dx = x - mx;
      const dy = y - my;
      const d2 = dx * dx + dy * dy;
      if (d2 < minDist2) {
        minDist2 = d2;
        bestIdx = idx;
      }
    }

    const radiusThreshold2 = 25; // ~5px
    if (bestIdx !== null && minDist2 <= radiusThreshold2) {
      highlightIndex = bestIdx;
      const [xr, yr, zr, wr] = rotated4List[bestIdx];
      coordHud.innerHTML =
        `<strong>vertex ${bestIdx}</strong> · ` +
        `(x', y', z', w') ≈ (${xr.toFixed(2)}, ${yr.toFixed(2)}, ${zr.toFixed(2)}, ${wr.toFixed(2)})`;
    } else {
      highlightIndex = null;
      coordHud.textContent =
        "Hover a vertex to inspect its rotated 4D coordinates.";
    }

    draw();
  });

  canvas.addEventListener("mouseleave", () => {
    highlightIndex = null;
    coordHud.textContent =
      "Hover a vertex to inspect its rotated 4D coordinates.";
    draw();
  });

  // Keyboard controls on the card
  card.addEventListener("keydown", (e) => {
    let handled = false;
    const stepView = 0.08;
    const stepW = 0.04;

    switch (e.key) {
      case "ArrowUp":
        viewRotX -= stepView;
        handled = true;
        break;
      case "ArrowDown":
        viewRotX += stepView;
        handled = true;
        break;
      case "ArrowLeft":
        viewRotY -= stepView;
        handled = true;
        break;
      case "ArrowRight":
        viewRotY += stepView;
        handled = true;
        break;
      case "q":
      case "Q":
        angleXW -= stepW;
        angleYW -= stepW * 0.5;
        handled = true;
        break;
      case "e":
      case "E":
        angleXW += stepW;
        angleYW += stepW * 0.5;
        handled = true;
        break;
      case "r":
      case "R":
        viewRotX = -0.6;
        viewRotY = 0.8;
        slider.value = "50";
        updateWAngle();
        handled = true;
        break;
    }

    if (handled) {
      userInteracted = true;
      valueLabel.innerHTML =
        `θ<sub>xw</sub> ≈ ${angleXW.toFixed(2)}, ` +
        `θ<sub>yw</sub> ≈ ${angleYW.toFixed(2)}`;
      draw();
      e.preventDefault();
    }
  });

  // Subtle auto-rotation until user interacts
  let lastTime = null;
  function animate(timestamp) {
    if (lastTime == null) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (!userInteracted) {
      angleXW += dt * 0.2;
      angleYW += dt * 0.11;
      draw();
      valueLabel.innerHTML =
        `θ<sub>xw</sub> ≈ ${angleXW.toFixed(2)}, ` +
        `θ<sub>yw</sub> ≈ ${angleYW.toFixed(2)}`;
    }

    window.requestAnimationFrame(animate);
  }

  draw();
  window.requestAnimationFrame(animate);
})();

  </script>
</body>
</html>

