<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dimensions Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #07090c;
      --card-bg: #10131a;
      --accent: #4ea1ff;
      --accent-soft: rgba(78, 161, 255, 0.15);
      --text-main: #e5e9f0;
      --text-muted: #8b92a4;
      --border-subtle: #1b232f;
      --inner-scale: 0.5; /* used for 4D "w" parameter */
      --radius-lg: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111522 0, #050609 45%, #020309 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 2rem 1rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1, h2, h3 {
      font-weight: 500;
      letter-spacing: 0.04em;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.9rem;
      max-width: 650px;
      text-align: center;
      margin-bottom: 2rem;
    }

    .badge {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent);
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(78,161,255,0.4);
      background: radial-gradient(circle at top, rgba(78,161,255,0.12), transparent 70%);
      margin-bottom: 0.75rem;
      display: inline-block;
    }

    .container {
      max-width: 1000px;
      width: 100%;
      display: grid;
      gap: 1.5rem;
    }

    @media (min-width: 900px) {
      .container {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .card {
      background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.6));
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 1.25rem 1.25rem 1rem;
      box-shadow: 0 18px 40px rgba(0,0,0,0.5);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at top left, rgba(78,161,255,0.07), transparent 55%),
        radial-gradient(circle at bottom right, rgba(166,77,255,0.06), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.75rem;
    }

    .card-title {
      font-size: 1rem;
      text-transform: uppercase;
    }

    .card-caption {
      color: var(--text-muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .card-body {
      margin-top: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .hint {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.25);
      font-size: 0.7rem;
    }

    .pill-dot {
      width: 0.4rem;
      height: 0.4rem;
      border-radius: 999px;
      background: var(--accent);
    }

    .controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .controls-row-right {
      margin-left: auto;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    /* 1D LINE --------------------------------------------------------- */

    .line-viewport {
      margin-top: 0.25rem;
      padding: 1rem 0.2rem 0.3rem;
    }

    .line-track {
      position: relative;
      height: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(78,161,255,0.08), rgba(78,161,255,0.6));
      overflow: visible;
    }

    .line-marker {
      position: absolute;
      top: 50%;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(78,161,255,0.9);
    }

    .line-value {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .line-slider {
      width: 100%;
    }

    /* 2D MATRIX ------------------------------------------------------- */

    .matrix-viewport {
      margin-top: 0.25rem;
      padding: 0.9rem 0.2rem 0.4rem;
    }

    .matrix-grid {
      --n: 5;
      display: grid;
      grid-template-columns: repeat(var(--n), 1.6rem);
      grid-auto-rows: 1.6rem;
      gap: 0.25rem;
      justify-content: center;
      margin-bottom: 0.5rem;
    }

    .matrix-cell {
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background: radial-gradient(circle at top, rgba(255,255,255,0.06), rgba(0,0,0,0.6));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .matrix-cell.active {
      border-color: var(--accent);
      background: radial-gradient(circle at top, rgba(78,161,255,0.3), rgba(0,0,0,0.85));
      color: #f8fbff;
      box-shadow: 0 0 18px rgba(78,161,255,0.6);
    }

    .matrix-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(3,6,12,0.85);
      color: var(--text-main);
      padding: 0.25rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      transition: border-color 0.12s ease, background 0.12s ease, transform 0.1s ease;
    }

    .btn.small {
      padding: 0.15rem 0.55rem;
      font-size: 0.75rem;
    }

    .btn:hover {
      border-color: var(--accent);
      background: rgba(78,161,255,0.18);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-ghost {
      background: transparent;
    }

    .coord-display {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* 3D & 4D VIEWPORTS ---------------------------------------------- */

    .viewport-3d {
      margin-top: 0.5rem;
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      background: radial-gradient(circle at top, rgba(255,255,255,0.06), rgba(0,0,0,0.95));
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .viewport-3d-inner {
      width: 8rem;
      height: 8rem;
      position: relative;
      perspective: 900px;
      cursor: grab;
    }

    .viewport-3d-inner.dragging {
      cursor: grabbing;
    }

    .rotator-3d {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      transform-origin: center;
      transition: transform 0.03s linear;
    }

    .cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
    }

    .cube.outer {
      /* outer cube just uses default size */
    }

    .cube.inner {
      position: absolute;
      inset: 0;
      margin: auto;
      transform-origin: center center;
      transform: scale(var(--inner-scale));
    }

    .face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: radial-gradient(circle at top left, rgba(78,161,255,0.12), rgba(0,0,0,0.9));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: var(--text-main);
      box-shadow: 0 0 24px rgba(0,0,0,0.7);
      backdrop-filter: blur(3px);
    }

    .cube.inner .face {
      border-style: dashed;
      border-color: rgba(78,161,255,0.9);
      background: radial-gradient(circle at top left, rgba(78,161,255,0.16), rgba(0,0,0,0.9));
      box-shadow: 0 0 35px rgba(78,161,255,0.85);
    }

    /* Cube face positions */
    .face.front  { transform: translateZ(4rem); }
    .face.back   { transform: rotateY(180deg) translateZ(4rem); }
    .face.right  { transform: rotateY(90deg) translateZ(4rem); }
    .face.left   { transform: rotateY(-90deg) translateZ(4rem); }
    .face.top    { transform: rotateX(90deg) translateZ(4rem); }
    .face.bottom { transform: rotateX(-90deg) translateZ(4rem); }

    .face-label {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      opacity: 0.92;
    }

    .axis-label {
      position: absolute;
      font-size: 0.65rem;
      color: var(--text-muted);
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      pointer-events: none;
      opacity: 0.85;
    }

    .axis-label.x { bottom: 0.45rem; right: 1.2rem; }
    .axis-label.y { top: 0.45rem; left: 1.2rem; }
    .axis-label.z { top: 0.45rem; right: 1.1rem; }

    .w-control {
      width: 100%;
    }

    .value-pill {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      color: var(--accent);
      background: var(--accent-soft);
      border-radius: 999px;
      padding: 0.1rem 0.6rem;
      border: 1px solid rgba(78,161,255,0.7);
    }

    /* Sliders */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 0 9px rgba(78,161,255,0.9);
      border: none;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 0 9px rgba(78,161,255,0.9);
      border: none;
    }

    input[type="range"]::-moz-range-track {
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
    }

  </style>
</head>
<body>
  <div class="badge">Dimensional Playground</div>
  <h1>Interactive Dimensions</h1>
  <p class="subtitle">
    A minimalistic static page showing 1D, 2D, 3D and a 4D-style tesseract projection.
    Drag, click, and slide to move through dimensions.
  </p>

  <main class="container">
    <!-- 1D -------------------------------------------------------------->
    <section class="card">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">1D · Line</h2>
            <div class="card-caption">Single coordinate <code>x</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            scalar position
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            Move the marker along the line. This is a single-degree-of-freedom space.
          </p>

          <div class="line-viewport">
            <div class="line-track" id="lineTrack">
              <div class="line-marker" id="lineMarker"></div>
            </div>
            <div class="line-value">
              <span>Position:</span>
              <span class="value-pill" id="lineValue">x = 0.00</span>
            </div>
          </div>

          <input
            class="line-slider"
            id="lineSlider"
            type="range"
            min="0"
            max="100"
            step="0.1"
            value="0"
          />
        </div>
      </div>
    </section>

    <!-- 2D -------------------------------------------------------------->
    <section class="card">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">2D · Grid</h2>
            <div class="card-caption">Coordinates <code>(x, y)</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            matrix navigation
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            Navigate the active cell using the buttons or your keyboard arrows.
          </p>

          <div class="matrix-viewport">
            <div class="matrix-grid" id="matrixGrid">
              <!-- cells are generated by JS -->
            </div>

            <div class="matrix-controls">
              <div class="controls-row">
                <div class="controls-row">
                  <button class="btn small" data-dir="up">↑</button>
                </div>
                <div class="controls-row">
                  <button class="btn small" data-dir="left">←</button>
                  <button class="btn small" data-dir="down">↓</button>
                  <button class="btn small" data-dir="right">→</button>
                </div>
              </div>
              <div class="coord-display" id="matrixCoord">
                (x, y) = (0, 0)
              </div>
            </div>
          </div>

          <p class="hint">
            Tip: focus this section and use your arrow keys to move.
          </p>
        </div>
      </div>
    </section>

    <!-- 3D -------------------------------------------------------------->
    <section class="card">
      <div class="card-inner">
        <div class="card-header">
          <div>
            <h2 class="card-title">3D · Cube</h2>
            <div class="card-caption">Coordinates <code>(x, y, z)</code></div>
          </div>
          <span class="pill">
            <span class="pill-dot"></span>
            drag to rotate
          </span>
        </div>
        <div class="card-body">
          <p class="hint">
            Click and drag inside the viewport to rotate the cube in 3D.
          </p>

          <div class="viewport-3d" id="cubeViewport">
            <div class="viewport-3d-inner" id="cubeViewportInner">
              <div class="rotator-3d" id="cubeRotator">
                <div class="cube">
                  <div class="face front"><span class="face-label">+Z</span></div>
                  <div class="face back"><span class="face-label">−Z</span></div>
                  <div class="face right"><span class="face-label">+X</span></div>
                  <div class="face left"><span class="face-label">−X</span></div>
                  <div class="face top"><span class="face-label">+Y</span></div>
                  <div class="face bottom"><span class="face-label">−Y</span></div>
                </div>
              </div>
            </div>

            <span class="axis-label x">x</span>
            <span class="axis-label y">y</span>
            <span class="axis-label z">z</span>
          </div>

          <div class="controls-row">
            <span class="hint">Hold mouse and drag to explore 3D rotations.</span>
          </div>
        </div>
      </div>
    </section>

    <!-- 4D -------------------------------------------------------------->
<!-- 4D -------------------------------------------------------------->
<section class="card">
  <div class="card-inner">
    <div class="card-header">
      <div>
        <h2 class="card-title">4D · Tesseract Projection</h2>
        <div class="card-caption">Coordinates <code>(x, y, z, w)</code></div>
      </div>
      <span class="pill">
        <span class="pill-dot"></span>
        4D → 3D → 2D
      </span>
    </div>
    <div class="card-body">
      <p class="hint">
        This is a real 4D hypercube (tesseract) projection: vertices live in
        <code>(x, y, z, w)</code>. The slider rotates in the 4D planes involving
        <code>w</code>, and dragging rotates the 3D viewpoint.
      </p>

      <div class="viewport-3d" id="tessViewport">
        <canvas id="tessCanvas"></canvas>
        <span class="axis-label x">x</span>
        <span class="axis-label y">y</span>
        <span class="axis-label z">z</span>
      </div>

      <div class="controls-row">
        <label class="hint" for="wSlider">
          4D rotation angle involving <code>w</code>:
        </label>
        <div class="controls-row-right">
          <input
            id="wSlider"
            class="w-control"
            type="range"
            min="0"
            max="100"
            step="1"
            value="50"
          />
          <span class="value-pill" id="wValue">w-angle ≈ 0.79 rad</span>
        </div>
      </div>
    </div>
  </div>
</section>

  </main>

  <script>
    // ---------------- 1D LINE ----------------------------------------
    (function init1D() {
      const slider = document.getElementById("lineSlider");
      const marker = document.getElementById("lineMarker");
      const valueLabel = document.getElementById("lineValue");

      function updateFromSlider() {
        const v = parseFloat(slider.value); // 0..100
        const frac = v / 100;
        marker.style.left = (frac * 100) + "%";
        valueLabel.textContent = "x = " + frac.toFixed(2);
      }

      slider.addEventListener("input", updateFromSlider);
      updateFromSlider();
    })();

    // ---------------- 2D MATRIX --------------------------------------
    (function init2D() {
      const grid = document.getElementById("matrixGrid");
      const coordLabel = document.getElementById("matrixCoord");
      const size = 5; // 5x5 grid

      grid.style.setProperty("--n", size);

      let x = 0;
      let y = 0;

      // build cells
      const cells = [];
      for (let row = 0; row < size; row++) {
        cells[row] = [];
        for (let col = 0; col < size; col++) {
          const cell = document.createElement("div");
          cell.className = "matrix-cell";
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.textContent = ""; // keep clean; could show indices if desired
          grid.appendChild(cell);
          cells[row][col] = cell;
        }
      }

      function updateActive() {
        cells.forEach(row => row.forEach(c => c.classList.remove("active")));
        cells[y][x].classList.add("active");
        coordLabel.textContent = `(x, y) = (${x}, ${y})`;
      }

      function move(dx, dy) {
        x = Math.max(0, Math.min(size - 1, x + dx));
        y = Math.max(0, Math.min(size - 1, y + dy));
        updateActive();
      }

      // button controls
      const btns = grid.parentElement.querySelectorAll("button[data-dir]");
      btns.forEach(btn => {
        btn.addEventListener("click", () => {
          const dir = btn.dataset.dir;
          if (dir === "up") move(0, -1);
          if (dir === "down") move(0, 1);
          if (dir === "left") move(-1, 0);
          if (dir === "right") move(1, 0);
        });
      });

      // keyboard arrows when focus is inside this card
      const card = grid.closest(".card");
      card.tabIndex = 0; // make focusable
      card.addEventListener("keydown", e => {
        switch (e.key) {
          case "ArrowUp":
            move(0, -1);
            e.preventDefault();
            break;
          case "ArrowDown":
            move(0, 1);
            e.preventDefault();
            break;
          case "ArrowLeft":
            move(-1, 0);
            e.preventDefault();
            break;
          case "ArrowRight":
            move(1, 0);
            e.preventDefault();
            break;
        }
      });

      updateActive();
    })();

    // Utility: drag-rotate for 3D rotators
    function attachDragRotation(viewportInner, rotator, startAngles) {
      let rotX = startAngles.x;
      let rotY = startAngles.y;
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      function applyTransform() {
        rotator.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
      }

      viewportInner.addEventListener("mousedown", (e) => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        viewportInner.classList.add("dragging");
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        rotY += dx * 0.5;
        rotX -= dy * 0.5;
        rotX = Math.max(-89, Math.min(89, rotX)); // limit polar angle a bit
        applyTransform();
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
        viewportInner.classList.remove("dragging");
      });

      viewportInner.addEventListener("mouseleave", () => {
        dragging = false;
        viewportInner.classList.remove("dragging");
      });

      applyTransform();
    }

    // ---------------- 3D CUBE ----------------------------------------
    (function init3D() {
      const inner = document.getElementById("cubeViewportInner");
      const rotator = document.getElementById("cubeRotator");
      attachDragRotation(inner, rotator, { x: -24, y: 32 });
    })();

// ---------------- 4D TESSERACT (REAL PROJECTION) --------------------
(function init4D() {
  const viewport = document.getElementById("tessViewport");
  const canvas = document.getElementById("tessCanvas");
  const slider = document.getElementById("wSlider");
  const valueLabel = document.getElementById("wValue");

  // Resize canvas to fit viewport
  function resizeCanvas() {
    const rect = viewport.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  const ctx = canvas.getContext("2d");

  // 16 vertices of a 4D hypercube: (±1, ±1, ±1, ±1)
  const vertices4D = [];
  for (let x of [-1, 1]) {
    for (let y of [-1, 1]) {
      for (let z of [-1, 1]) {
        for (let w of [-1, 1]) {
          vertices4D.push([x, y, z, w]);
        }
      }
    }
  }

  // Build edge list: connect vertices that differ in exactly one coordinate
  const edges = [];
  for (let i = 0; i < vertices4D.length; i++) {
    for (let j = i + 1; j < vertices4D.length; j++) {
      let diff = 0;
      for (let k = 0; k < 4; k++) {
        if (vertices4D[i][k] !== vertices4D[j][k]) diff++;
      }
      if (diff === 1) edges.push([i, j]);
    }
  }

  // 4D rotation angles
  // We'll rotate in two 4D planes involving w:
  //  - XW plane
  //  - YW plane
  let angleXW = Math.PI / 4;
  let angleYW = Math.PI / 6;

  // 3D view angles (like camera yaw/pitch) controlled by dragging
  let viewRotX = -0.6; // around X axis
  let viewRotY = 0.8;  // around Y axis

  // Drag handling on the whole viewport
  let dragging = false;
  let lastX = 0;
  let lastY = 0;

  viewport.addEventListener("mousedown", (e) => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  window.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    // adjust 3D view angles
    viewRotY += dx * 0.005;
    viewRotX += dy * 0.005;

    draw();
  });

  window.addEventListener("mouseup", () => {
    dragging = false;
  });

  viewport.addEventListener("mouseleave", () => {
    dragging = false;
  });

  // Slider: map 0..100 -> 0..π for 4D rotation strength
  function updateWAngle() {
    const v = parseInt(slider.value, 10); // 0..100
    const a = (v / 100) * Math.PI;       // 0..π
    angleXW = a * 0.7; // some variation between XW and YW
    angleYW = a * 0.4;
    valueLabel.textContent = `w-angle ≈ ${a.toFixed(2)} rad`;
    draw();
  }

  slider.addEventListener("input", updateWAngle);
  updateWAngle();

  // ---- math helpers ----
  function rotate4D_XW(p, angle) {
    // rotate in X-W plane: (x, y, z, w)
    const [x, y, z, w] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const x2 = x * c + w * s;
    const w2 = -x * s + w * c;
    return [x2, y, z, w2];
  }

  function rotate4D_YW(p, angle) {
    // rotate in Y-W plane
    const [x, y, z, w] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const y2 = y * c + w * s;
    const w2 = -y * s + w * c;
    return [x, y2, z, w2];
  }

  function rotate3D_X(p, angle) {
    // rotate around X axis: (x, y, z)
    const [x, y, z] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const y2 = y * c - z * s;
    const z2 = y * s + z * c;
    return [x, y2, z2];
  }

  function rotate3D_Y(p, angle) {
    const [x, y, z] = p;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const x2 = x * c + z * s;
    const z2 = -x * s + z * c;
    return [x2, y, z2];
  }

  function projectTo2D(p3) {
    const [x, y, z] = p3;
    const { width, height } = canvas;
    const scale = Math.min(width, height) * 0.22;
    const cx = width / 2;
    const cy = height / 2;

    // simple perspective based on z
    const depth = 3; // camera distance
    const factor = depth / (depth + z);
    const sx = x * scale * factor + cx;
    const sy = y * scale * factor + cy;
    return [sx, sy];
  }

  function draw() {
    const { width, height } = canvas;
    ctx.clearRect(0, 0, width, height);

    // Compute projected positions
    const projected = vertices4D.map(v => {
      // 4D rotation first
      let p4 = v;
      p4 = rotate4D_XW(p4, angleXW);
      p4 = rotate4D_YW(p4, angleYW);

      // drop w -> we get (x, y, z)
      let [x, y, z, w] = p4;
      let p3 = [x, y, z];

      // 3D view rotations (camera-like)
      p3 = rotate3D_X(p3, viewRotX);
      p3 = rotate3D_Y(p3, viewRotY);

      // project to screen
      return projectTo2D(p3);
    });

    // Draw edges
    ctx.lineWidth = 1.2;
    for (const [i, j] of edges) {
      const [x1, y1] = projected[i];
      const [x2, y2] = projected[j];

      // inner edges (vertices with w=+1) vs outer (w=-1) show slightly different opacity
      const w1 = vertices4D[i][3];
      const w2 = vertices4D[j][3];
      const inner = (w1 > 0 && w2 > 0);
      const alpha = inner ? 0.95 : 0.4;

      ctx.strokeStyle = `rgba(78,161,255,${alpha})`;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // Draw vertices
    for (let idx = 0; idx < projected.length; idx++) {
      const [x, y] = projected[idx];
      const w = vertices4D[idx][3];
      const inner = w > 0;

      ctx.beginPath();
      ctx.arc(x, y, inner ? 3.2 : 2.6, 0, Math.PI * 2);
      ctx.fillStyle = inner
        ? "rgba(78,161,255,1)"
        : "rgba(190,205,255,0.7)";
      ctx.fill();
    }
  }

  draw();
})();

  </script>
</body>
</html>
